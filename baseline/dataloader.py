"""Pytorch dataset object that loads a Malware Patches dataset as images."""

import math
import numpy as np
import pandas as pd
from pathlib import Path
import torch.utils.data as data_utils
from PIL import Image
from torchvision import transforms
from tqdm import tqdm
import os.path

class Malware(data_utils.Dataset):
    def __init__(self, mal_dir, labels_file, small_images_dir, channels = 1, transform=transforms.Compose([transforms.ToTensor()]), target_transform=None, test=False, adversarial=False, adversarial_type="zeros"):
        self.mal_dir = mal_dir
        self.mal_labels = pd.read_csv(labels_file)
        self.transform = transform
        self.target_transform = target_transform
        self.channels = channels
        self.adversarial = adversarial
        self.adversarial_type = adversarial_type
        self.small_images_dir = small_images_dir

        # If small images are pre-computed, load them instead of making them from scratch from .bin files
        if (self.small_images_dir):
            self.images = self._load_images()
        else:
            self.images = self._make_and_load_images()

        if test:
            # List of images sorted in order of mal_labels, to make confusion matrix image matching more efficient
            self.images_sorted = [self.images[sample_id] for sample_id in self.mal_labels["Id"]]

    def _load_images(self):
        # Check if the samples exist
        print("Checking samples exist")
        for sample_id in tqdm(self.mal_labels['Id'], ascii=True):
            img_path = Path(f'{self.small_images_dir}/{sample_id}.bmp')
            if (not os.path.isfile(img_path)):
                print(f"File doesn't exist: {sample_id}")
        
        # Load the samples as images into memory
        images_list = {}
        print("Loading images from filesystem")
        for sample_id in tqdm(self.mal_labels['Id'], ascii=True):
            img_path = Path(f'{self.small_images_dir}/{sample_id}.bmp')
            img = Image.open(img_path)

             # 3-channel option for when using pre-trained models
            if (self.channels == 3):
                img = img.convert('RGB')

            # Convert to tensor & normalise to [0-1]
            img = self.transform(img)
            
            images_list[sample_id] = img
        print("All images loaded")
        return images_list
            

    def _make_and_load_images(self):
        # Check if the samples exist
        print("Checking samples exist")
        for sample_id in tqdm(self.mal_labels['Id'], ascii=True):
            bin_path = Path(f'{self.mal_dir}/{sample_id}.bin')
            if (not os.path.isfile(bin_path)):
                print(f"File doesn't exist: {sample_id}")

        # Load the samples as images into memory
        images_list = {}
        print("Creating and Loading images")
        for sample_id in tqdm(self.mal_labels['Id'], ascii=True):
            bin_path = Path(f'{self.mal_dir}/{sample_id}.bin')
            try:
                bin_data = np.fromfile(bin_path, dtype=np.uint8)
            except:
                print(f'Not available: {sample_id}')
                continue
            
            # Load the malware image and resize it to the square root (square image)
            # If adversarial, pad the image to 10,000x10,000px
            if self.adversarial:
                if self.adversarial_type == "zeros":
                    bin_data.resize(10000*10000) # padding with zeros
                    data = bin_data.reshape((10000,10000))
                else:
                    pad_data = (np.random.rand(10000*10000 - len(bin_data))*255).astype(np.uint8) # Uniform random noise 0-255
                    padded_bin_data = np.concatenate((bin_data, pad_data))
                    data = padded_bin_data.reshape((10000,10000))
            else:
                sqrt = int(math.ceil(math.sqrt(len(bin_data))))
                bin_data.resize(sqrt**2) # Pad to sqrt*sqrt
                data = bin_data.reshape((sqrt, sqrt))
            
            # Resize the image
            img = Image.fromarray(data)
            img = img.resize((224, 224), resample=Image.BILINEAR)
            #if self.adversarial:
                #img.save(f"data_sets/BIG2015/train_images_small/{sample_id}.bmp")
            
            # 3-channel option for when using pre-trained models
            if (self.channels == 3):
                img = img.convert('RGB')

            # Convert to tensor & normalise to [0-1]
            img = self.transform(img)
            
            images_list[sample_id] = img
        print("All images loaded")
        return images_list

    def __len__(self):
        return len(self.mal_labels)

    def __getitem__(self, index):
        label = self.mal_labels.iloc[index, 1]
        sample_id = self.mal_labels.iloc[index, 0]

        image = self.images[sample_id]
        if self.target_transform:
            label = self.target_transform(label)

        return image, label
    
    def get_sample_id_by_index(self, index):
        sample_id = self.mal_labels.iloc[index, 0]
        return sample_id
